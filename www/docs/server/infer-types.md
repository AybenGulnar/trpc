---
id: infer-types
title: Inferring Types
sidebar_label: Inferring Types
slug: /infer-types
---

<!-- Reusable snippet -->

```twoslash include server
// @module: esnext
// @filename: server.ts
import { initTRPC } from '@trpc/server';
import { z } from "zod";

const t = initTRPC()();

const appRouter = t.router({
  user: t.router({
    me: t.procedure.query(() => {
      // imaginary query for current user
      return { id: 1, name: 'John' };
    }),
  }),
  postCreate: t.procedure.input(z.string())
    .mutation(({ input }) => {
      // imaginary db call
      return { id: 1, title: 'tRPC is the best!' };
    }),
});

export type AppRouter = typeof appRouter;
```

It is often useful to wrap functionality of your `@trpc/client` or `@trpc/react` api within other functions. For this purpose, it's necessary to be able to infer input types and output types generated by your `@trpc/server` router.

## Inference Helpers

`@trpc/server` exports the following helper types to assist with inferring these types from the `AppRouter` exported by your `@trpc/server` router:

- `inferProcedureOutput<TProcedure>`
- `inferProcedureInput<TProcedure>`

Let's assume we have this example router:

```ts twoslash title='server.ts'
// @include: server
```

By traversing the router object, you can infer the types of the procedures. The following example shows how to infer the types of the procedures of the example `appRouter`:

```ts twoslash title="client.ts"
// @module: esnext
// @include: server
// ---cut---
// @filename: client.ts
import type { inferProcedureInput, inferProcedureOutput } from '@trpc/server';
import type { AppRouter } from './server';

// @noErrors
type UserOutput = inferProcedureOutput<AppRouter['user']['me']>;
//   ^?
type PostInput = inferProcedureInput<AppRouter['postCreate']>;
//   ^?
```

### Additional DX Helper Type

if you don't like the double-import of first the inferance helper, then your `AppRouter` everytime you want to infer a type, `@trpc/server` also exports a type `GetInferanceHelpers<TRouter>`. This lets you pass your router at initialization then import a single helper type when inferring types:

```ts twoslash title='utils/trpc.ts'
// @include: server
// ---cut---
import type { GetInferenceHelpers } from '@trpc/server';
import type { AppRouter } from './server';

// @noErrors
export type InferTRPC = GetInferenceHelpers<AppRouter>;
```

```ts twoslash
// @module: esnext
// @include: server
// @filename: utils.ts
import type { GetInferenceHelpers } from '@trpc/server';
import type { AppRouter } from './server';
export type InferTRPC = GetInferenceHelpers<AppRouter>;
// @filename: index.ts
// ---cut---
import { InferTRPC } from './utils';

type UserOutput = InferTRPC['user']['me']['output'];
//   ^?
type PostInput = InferTRPC['postCreate']['input'];
//   ^?
```

## Infer `TRPClientError`s based on your router

```ts title='src/client.ts'
import { TRPCClientError } from '@trpc/client';
import type { AppRouter } from '~/server/routers/_app';
import { trpc } from './trpc';

export function isTRPCClientError(
  cause: unknown,
): cause is TRPCClientError<AppRouter> {
  return cause instanceof TRPCClientError;
}

async function main() {
  try {
    await trpc.postById.query({ id: 1 });
  } catch (cause) {
    if (isTRPCClientError(cause)) {
      // `cause` is now typed as your router's `TRPCClientError`
      console.log('data', cause.data);
      //                   ^?
    } else {
      // [...]
    }
  }
}

main();
```
